# Example: Setup BoringCache CLI directly
# Use this when you need direct CLI access for custom workflows

name: Setup CLI

on:
  push:
    branches: [main]
  pull_request:

jobs:
  # Basic CLI setup
  basic:
    runs-on: ubuntu-latest
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      # Install BoringCache CLI
      - uses: boringcache/setup-boringcache@v1

      # CLI is now available
      - run: boringcache --version
      - run: boringcache workspaces

  # Pin specific CLI version
  pinned-version:
    runs-on: ubuntu-latest
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - uses: boringcache/setup-boringcache@v1
        with:
          version: v1.0.1  # Pin to specific version

      - run: boringcache --version

  # Custom workflow with CLI
  custom-workflow:
    runs-on: ubuntu-latest
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - uses: boringcache/setup-boringcache@v1

      # Use CLI directly for custom caching logic
      - name: Restore dependencies
        run: |
          boringcache restore \
            ${{ github.repository }} \
            deps:node_modules \
            --verbose \
            || echo "Cache miss, will install"

      - run: npm ci

      - name: Save dependencies
        run: |
          boringcache save \
            ${{ github.repository }} \
            deps:node_modules \
            --verbose \
            --exclude "*.log"

  # Matrix build with CLI
  matrix:
    runs-on: ${{ matrix.os }}
    env:
      BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4

      - uses: boringcache/setup-boringcache@v1

      - run: boringcache --version
      - run: boringcache workspaces
